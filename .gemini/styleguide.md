## 리뷰 원칙

- 목표: **가독성 / 유지보수성 / 변경 용이성**을 높인다
- **동작 변경 없는 리팩터링**을 우선한다 (동작 변경이 필요한 제안은 *별도 표기*)
- 지적만 하지 말고 **대안(리팩터링 방향) + 짧은 예시 코드**를 함께 제시한다
- 한 번에 **가장 효과 큰 3~7개**만 우선 제안한다
- 확신이 낮으면 **“추정”**이라고 표시한다

## 리뷰 우선순위(중요도 순)

- **명확성(가독성)**: 이름/구조/흐름이 한 번에 이해되는가
- **응집도/결합도**: 한 함수/클래스가 한 가지 책임인가, 의존이 과한가
- **중복 제거(DRY)**: 반복 로직/매직넘버/유사 코드 정리
- **에러 처리/경계값**: 실패 케이스가 명확하고 일관적인가
- **테스트 가능성**: 순수 로직 분리, 의존성 주입, 사이드이펙트 격리
- **성능/리소스**: 명확성을 해치지 않는 범위에서만 제안

---

## 네이밍 규칙

- 함수/변수/클래스 이름은 **의도**를 드러낸다
- Boolean은 `is/has/can/should`로 시작한다
- 축약어/모호한 단어 남발 금지: `data`, `info`, `temp`, `obj`, `value` (필요 시 구체화)
- 컬렉션은 **복수형**, 단일 값은 **단수형**으로 일관성 유지
- 매직넘버/문자열은 **상수화**하고 의미 있는 이름을 부여한다

## 함수/메서드 규칙

- 한 함수는 **한 가지 일(SRP)**만 한다
- 인자 4개 이상이면 **DTO/객체로 묶기**를 검토한다
- 부수효과(IO/DB/네트워크/상태 변경)는 경계로 밀어내고 **순수 로직과 분리**한다
- 중첩이 깊으면(3단 이상) **가드 클로즈(early return)** 또는 **함수 추출**로 평탄화한다
- 동일한 패턴(검증/변환/로깅/예외)은 **공통화**한다

## 조건/흐름 규칙

- 복잡한 조건은 **의미 있는 이름의 변수/함수**로 추출한다
- 불필요한 `else`는 제거하고 **early return**을 선호한다
- 분기(조건)가 늘어나는 로직은 **스위치/매핑/전략(Strategy)**로 단순화한다
- 예외 케이스(경계값)는 흐름 초기에 처리해 **주요 흐름을 깨끗하게** 유지한다

## 구조/책임 분리

- 계층(예: Controller/Service/Repository) 책임이 섞이지 않게 한다
- 도메인 규칙은 **도메인/서비스에**, I/O는 **어댑터/인프라 경계**로 보낸다
- 전역/싱글톤 의존 남발 금지, 의존성은 **주입 가능**하게 만든다

## 에러 처리

- 예외/에러 메시지는 **원인 + 해결 힌트**가 있어야 한다
- 예외 타입/에러 코드는 **일관성** 있게 관리한다
- 실패를 숨기지 않는다: 의미 없는 `catch` 후 무시 금지
- 반환/예외 정책을 통일한다(예: 검증 실패는 어떤 방식으로 처리하는지)

## 주석/문서화

- 주석은 “무엇을”이 아니라 **“왜”**를 설명한다
- 코드로 표현 가능한 주석은 코드로 대체한다(함수 추출/이름 개선)
- TODO는 **근거/기한/담당**이 없으면 남기지 않는다

## 포맷/컨벤션

- 파일/클래스/메서드 길이가 과도하면 **쪼갠다**
- 네이밍/들여쓰기/스타일은 프로젝트 컨벤션에 맞춰 **일관성** 유지
- import 정리 및 unused 제거

## 네이밍 규칙

- 메소드/변수명은 **애매하면 안 되고 확실해야 한다** (의도가 한 번에 읽혀야 함)
- `data`, `info`, `temp`, `obj`, `value`, `result`, `param` 같은 **포괄 단어 금지**(불가피하면 접두/접미로 구체화: `userEmail`, `orderTotalAmount`)
- Boolean은 `is/has/can/should`로 시작하고, **부정형**(`isNot`, `notValid`) 남발 금지 → 긍정형으로 설계
- 컬렉션은 **복수형**, 단일 값은 **단수형** 유지
- 함수명은 **동사 + 목적어** 형태로 명확하게 (`validateToken`, `calculateTotalPrice`)

## 타입/가독성 규칙

- `var` 사용 금지 (명시적 타입으로 의도를 드러낸다)
- 너무 긴 체이닝/중첩 표현은 **중간 변수로 분해**해 읽기 쉽게 만든다
- 매직넘버/문자열은 **상수화**하고 의미 있는 이름을 부여한다
- 불필요한 축약어/약어 금지 (팀에서 합의된 약어만 허용)

## 함수/메서드 규칙

- 한 함수는 **한 가지 책임(SRP)**만 가진다
- 인자 4개 이상이면 **DTO/객체로 묶기**를 검토한다
- 부수효과(IO/DB/HTTP/시간/랜덤)는 경계로 밀어내고 **순수 로직과 분리**한다
- 조건문 중첩 3단 이상 금지 → **early return / 함수 추출**로 평탄화
- 중복 로직은 유틸/서비스로 **공통화(DRY)** 한다

## 조건/흐름 규칙

- 복잡한 조건은 **이름 있는 변수/함수**로 추출한다 (`isEligibleForDiscount`)
- 불필요한 `else` 제거(early return 선호)
- 분기 증가 로직은 **매핑/전략 패턴**으로 단순화 검토
- 예외/경계값 처리는 흐름 초기에 처리해 **메인 플로우를 깔끔하게** 유지

## 단위 테스트 가이드라인

- 모든 “의미 있는 로직”은 단위 테스트 대상이다 (계산/검증/변환/분기)
- 단위 테스트는 **빠르고, 결정적(deterministic)** 이어야 한다
    - 시간/랜덤/네트워크/DB에 의존하지 말 것(필요하면 Mock/Fake로 격리)
- 테스트는 **AAA 패턴**을 따른다: Arrange(준비) / Act(실행) / Assert(검증)
- 테스트 케이스는 최소로도 아래를 포함한다
    - 정상 케이스 1개 이상
    - 경계값(빈 값, 0, 최소/최대, null 가능성)
    - 실패 케이스(예외/에러 코드/검증 실패)
- 테스트 이름은 “상황-행동-기대결과”가 드러나게 작성한다
    - 예: `givenInvalidToken_whenValidate_thenThrowAuthException`
- 한 테스트는 **한 가지 이유로만 실패**해야 한다 (assert 남발 금지, 핵심 검증만)
- 구현 디테일에 과도하게 결합된 테스트 금지
    - 내부 메서드 호출 횟수 검증 남발 금지(진짜 필요한 곳만)
- 단위 테스트는 “리팩터링 안전망”이어야 한다
    - 동작 동일 리팩터링 시 테스트가 그대로 통과해야 한다

## DTO 규칙

- DTO는 Java record로 작성한다(불변, 의도 명확, 보일러플레이트 최소화)

```java
public record UserSignUpRequest(String email, String password) {}
```

## 데이터 접근 규칙 (JPA)

- 동적 쿼리/복잡한 조회는 **JPQL 대신 QueryDSL**로 작성한다
- JPQL이 남아있다면 “QueryDSL 전환”을 우선 개선안으로 제시한다
- 조회 성능 이슈 소지가 있으면 **N+1 / fetch join / 페이징 호환성**을 함께 점검한다

## 코드리뷰 작성 언어

- 코드리뷰 코멘트는 **반드시 한글로 작성**한다
- 용어는 가능한 한 일관되게 사용한다(예: “응집도/결합도”, “가드 클로즈”, “상수화”)

## 상수화 / 매직넘버 규칙

- 매직넘버/매직스트링이 남아있는지 반드시 확인한다
    - 예: `2000`, `3`, `"SUCCESS"`, `"/api/v1"` 등
- 의미가 있는 값은 **static final 상수(또는 enum)** 로 상수화한다
- 상수명은 값의 “의도/단위/범위”가 드러나게 작성한다
    - 예: `CONNECT_TIMEOUT_MS`, `MAX_RETRY_COUNT`, `DEFAULT_PAGE_SIZE`
- 도메인 값 묶음은 상수보다 **enum/VO**를 우선 검토한다
---

## 리뷰 출력 형식(봇 출력 고정)

- **요약(3줄 이내)**: 가장 큰 문제/개선 효과
- **Top Issues (1~5)**: 문제 한 줄 → 영향 → 개선안 → (가능하면) 짧은 코드 예시
- **리팩터링 제안(작은 커밋 단위)**: Commit 1 / Commit 2 …
- **칭찬 1~2개**: 잘된 점만 짧게
